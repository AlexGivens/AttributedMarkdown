%{
/**********************************************************************

  markdown_parser.leg - markdown parser in C using a PEG grammar.
  (c) 2008 John MacFarlane (jgm at berkeley dot edu).

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; version 2 of the License.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

 ***********************************************************************/

#include <stdbool.h>
#include <assert.h>
#include "markdown_peg.h"

extern int strcasecmp(const char *string1, const char *string2);
int yyparse(void);

/**********************************************************************

  List manipulation functions

 ***********************************************************************/

/* cons - cons an element onto a list, returning pointer to new head */
element *cons(element *new, element *list) {
    assert(new != NULL);
    new->next = list;
    return new;
}

/* reverse - reverse a list, returning pointer to new list */
element *reverse(element *list) {
    element *new = NULL;
    element *next = NULL;
    while (list != NULL) {
        next = list->next;
        new = cons(list, new);
        list = next;
    }
    return new;
}

/* concat_string_list - concatenates string contents of list of STR elements.
 * Frees STR elements as they are added to the concatenation. */
static GString *concat_string_list(element *list) {
    GString *result;
    element *next;
    result = g_string_new("");
    while (list != NULL) {
        assert(list->key == STR);
        assert(list->contents.str != NULL);
        g_string_append(result, list->contents.str);
        next = list->next;
        #ifdef __DEBUG__
          fprintf(stderr,"Freed element for %d - %d\n", list->key, list);
        #endif
        free_element(list);
        list = next;
    }
    return result;
}

/**********************************************************************

  Global variables used in parsing

 ***********************************************************************/

static char *charbuf = "";     /* Buffer of characters to be parsed. */
static element *references;    /* List of link references found. */
static element *notes;         /* List of footnotes found. */
static element *parse_result;  /* Results of parse. */
static int syntax_extensions;  /* Syntax extensions selected. */

/**********************************************************************

  Auxiliary functions for parsing actions.
  These make it easier to build up data structures (including lists)
  in the parsing actions.

 ***********************************************************************/

/* mk_element - generic constructor for element */
static element * mk_element(int key) {
    element *result = malloc(sizeof(element));
    #ifdef __DEBUG__
      fprintf(stderr,"Allocated element for %d - %d\n", key, result);
    #endif
    result->key = key;
    result->children = NULL;
    result->next = NULL;
    result->contents.str = NULL;
    return result;
}

/* mk_str - constructor for STR element */
static element * mk_str(char *string) {
    element *result;
    assert(string != NULL);
    result = mk_element(STR);
    result->contents.str = strdup(string);
    return result;
}

/* mk_str_from_list - makes STR element by concatenating a
 * reversed list of strings, adding optional extra newline */
static element * mk_str_from_list(element *list, bool extra_newline) {
    element *result;
    GString *c = concat_string_list(reverse(list));
    if (extra_newline)
        g_string_append(c, "\n");
    result = mk_element(STR);
    result->contents.str = c->str;
    g_string_free(c, false);
    return result;
}

/* mk_list - makes new list with key 'key' and children the reverse of 'lst'.
 * This is designed to be used with pushelt to build lists in a parser action.
 * The reversing is necessary because pushelt adds to the head of a list. */
static element * mk_list(int key, element *lst) {
    element *result;
    result = mk_element(key);
    result->children = reverse(lst);
    return result;
}

/* mk_link - constructor for LINK element */
static element * mk_link(element *label, char *url, char *title) {
    element *result;
    result = mk_element(LINK);
    result->contents.link = malloc(sizeof(link));
    result->contents.link->label = label;
    result->contents.link->url = strdup(url);
    result->contents.link->title = strdup(title);
    return result;
}

/* extension = returns true if extension is selected */
static bool extension(int ext) {
    return (syntax_extensions & ext);
}

/* match_inlines - returns true if inline lists match (case-insensitive...) */
static bool match_inlines(element *l1, element *l2) {
    while (l1 != NULL && l2 != NULL) {
      if (l1->key != l2->key)
            return false;
        switch (l1->key) {
        case SPACE:
        case LINEBREAK:
            break;
        case CODE:
        case STR:
        case HTML:
            if (strcasecmp(l1->contents.str, l2->contents.str) == 0)
                break;
            else
                return false;
        case EMPH:
        case STRONG:
        case LIST:
            if (match_inlines(l1->children, l2->children))
                break;
            else
                return false;
        case LINK:
        case IMAGE:
            return false;  /* No links or images within links */
        default:
            fprintf(stderr, "match_inlines encountered unknown key = %d\n", l1->key);
            exit(EXIT_FAILURE);
            break;
        }
        l1 = l1->next;
        l2 = l2->next;
    }
    return (l1 == NULL && l2 == NULL);  /* return true if both lists exhausted */
}

/* find_reference - return true if link found in references matching label.
 * 'link' is modified with the matching url and title. */
static bool find_reference(link *result, element *label) {
    element *cur = references;  /* pointer to walk up list of references */
    link *curitem;
    while (cur != NULL) {
        curitem = cur->contents.link;
        if (match_inlines(label, curitem->label)) {
            *result = *curitem;
            return true;
        }
        else
            cur = cur->next;
    }
    return false;
}

/* find_note - return true if note found in notes matching label.
if found, 'result' is set to point to matched note. */

static bool find_note(element **result, char *label) {
   element *cur = notes;  /* pointer to walk up list of notes */
   while (cur != NULL) {
       if (strcmp(label, cur->contents.str) == 0) {
           *result = cur;
           return true;
       }
       else
           cur = cur->next;
   }
   return false;
}

/**********************************************************************

  Definitions for leg parser generator.
  YY_INPUT is the function the parser calls to get new input.
  We take all new input from (static) charbuf.

 ***********************************************************************/

# define YYSTYPE element *
#ifdef __DEBUG__
# define YY_DEBUG 1
#endif

#define YY_INPUT(buf, result, max_size)              \
{                                                    \
    int yyc;                                         \
    if (charbuf && *charbuf != '\0') {               \
        yyc= *charbuf++;                             \
    } else {                                         \
        yyc= EOF;                                    \
    }                                                \
    result= (EOF == yyc) ? 0 : (*(buf)= yyc, 1);     \
}

/**********************************************************************

  PEG grammar and parser actions for markdown syntax.

 ***********************************************************************/

%}

Doc =       a:StartList ( Block { a = cons($$, a); } )*
            { parse_result = reverse(a); }

Block =     BlankLine*
            ( BlockQuote
            | Verbatim
            | Note
            | Reference
            | Heading
            | OrderedList
            | BulletList
            | HorizontalRule
            | HtmlBlock
            | Para
            | Plain )

Para =      NonindentSpace a:Inlines BlankLine+
            { $$ = a; $$->key = PARA; }

Plain =     a:Inlines
            { $$ = a; $$->key = PLAIN; }

AtxInline = !Newline !(Sp '#'* Sp Newline) Inline

AtxStart =  < ( "######" | "#####" | "####" | "###" | "##" | "#" ) >
            { $$ = mk_element(H1 + (strlen(yytext) - 1)); }

AtxHeading = s:AtxStart Sp a:StartList ( AtxInline { a = cons($$, a); } )+ (Sp '#'* Sp)?  Newline
            { $$ = mk_list(s->key, a); }

SetextHeading = SetextHeading1 | SetextHeading2

SetextHeading1 =  a:StartList ( !Endline Inline { a = cons($$, a); } )+ Newline "===" '='* Newline
                  { $$ = mk_list(H1, a); }

SetextHeading2 =  a:StartList ( !Endline Inline { a = cons($$, a); } )+ Newline "---" '-'* Newline
                  { $$ = mk_list(H2, a); }

Heading = AtxHeading | SetextHeading

BlockQuote = a:BlockQuoteRaw
             {  $$ = mk_element(BLOCKQUOTE);
                $$->children = a;
             }

BlockQuoteRaw =  a:StartList
                 (( '>' ' '? Line { a = cons($$, a); } )
                  ( !'>' !BlankLine Line { a = cons($$, a); } )*
                  ( BlankLine { a = cons(mk_str("\n"), a); } )*
                 )+
                 {   $$ = mk_str_from_list(a, true);
                     $$->key = RAW;
                 }

NonblankIndentedLine = !BlankLine IndentedLine

VerbatimChunk = a:StartList
                ( BlankLine { a = cons(mk_str("\n"), a); } )*
                ( NonblankIndentedLine { a = cons($$, a); } )+
                { $$ = mk_str_from_list(a, false); }

Verbatim =     a:StartList ( VerbatimChunk { a = cons($$, a); } )+
               { $$ = mk_str_from_list(a, false);
                 $$->key = VERBATIM; }

HorizontalRule = NonindentSpace
                 ( '*' Sp '*' Sp '*' (Sp '*')*
                 | '-' Sp '-' Sp '-' (Sp '-')*
                 | '_' Sp '_' Sp '_' (Sp '_')*)
                 Sp Newline BlankLine+
                 { $$ = mk_element(HRULE); }

Bullet = NonindentSpace ('+' | '*' | '-') Spacechar+

BulletList = BulletListTight | BulletListLoose

BulletListTight = a:StartList
                  ( BulletListItem { a = cons($$, a); } )+
                  BlankLine* !BulletListLoose
                  { $$ = mk_list(BULLETLIST, a); }

BulletListLoose = a:StartList
                  ( b:BulletListItem BlankLine*
                    {   element *li;
                        li = b->children;
                        li->contents.str = realloc(li->contents.str, strlen(li->contents.str) + 3);
                        strcat(li->contents.str, "\n\n");  /* In loose list, \n\n added to end of each element */
                        a = cons(b, a);
                    } )+
                  { $$ = mk_list(BULLETLIST, a); }

BulletListItem = !HorizontalRule &Bullet ListItem

ListItem =       ( Bullet | Enumerator )
                 a:StartList
                 ListBlock { a = cons($$, a); }
                 ( ListContinuationBlock { a = cons($$, a); } )*
                 {  element *raw;
                    raw = mk_str_from_list(a, false);
                    raw->key = RAW;
                    $$ = mk_element(LISTITEM);
                    $$->children = raw;
                 }

ListBlock = a:StartList
            Line { a = cons($$, a); }
            ( ListBlockLine { a = cons($$, a); } )*
            { $$ = mk_str_from_list(a, false); }

ListContinuationBlock = a:StartList
                        ( < BlankLine* >
                          {   if (strlen(yytext) == 0)
                                   a = cons(mk_str("\001"), a); /* block separator */
                              else
                                   a = cons(mk_str(yytext), a); } )
                        ( Indent ListBlock { a = cons($$, a); } )+
                        {  $$ = mk_str_from_list(a, false); }

Enumerator = NonindentSpace [0-9]+ '.' Spacechar+

OrderedList = OrderedListTight | OrderedListLoose

OrderedListTight = a:StartList
                  ( OrderedListItem { a = cons($$, a); } )+
                  BlankLine* !OrderedListLoose
                  { $$ = mk_list(ORDEREDLIST, a); }

OrderedListLoose = a:StartList
                  ( b:OrderedListItem BlankLine*
                    {   element *li;
                        li = b->children;
                        li->contents.str = realloc(li->contents.str, strlen(li->contents.str) + 3);
                        strcat(li->contents.str, "\n\n");  /* In loose list, \n\n added to end of each element */
                        a = cons(b, a);
                    } )+
                  { $$ = mk_list(ORDEREDLIST, a); }

OrderedListItem =   !HorizontalRule &Enumerator ListItem

ListBlockLine = !( Indent? ( BulletListItem | OrderedListItem ) )
                !BlankLine
                OptionallyIndentedLine

# Parsers for different kinds of block-level HTML content.
# This is repetitive due to constraints of PEG grammar.

HtmlBlockOpenAddress = '<' Spnl ("address" | "ADDRESS") Spnl HtmlAttribute* '>'
HtmlBlockCloseAddress = '<' Spnl '/' ("address" | "ADDRESS") Spnl '>'

HtmlBlockOpenBlockquote = '<' Spnl ("blockquote" | "BLOCKQUOTE") Spnl HtmlAttribute* '>'
HtmlBlockCloseBlockquote = '<' Spnl '/' ("blockquote" | "BLOCKQUOTE") Spnl '>'

HtmlBlockOpenCenter = '<' Spnl ("center" | "CENTER") Spnl HtmlAttribute* '>'
HtmlBlockCloseCenter = '<' Spnl '/' ("center" | "CENTER") Spnl '>'

HtmlBlockOpenDir = '<' Spnl ("dir" | "DIR") Spnl HtmlAttribute* '>'
HtmlBlockCloseDir = '<' Spnl '/' ("dir" | "DIR") Spnl '>'

HtmlBlockOpenDiv = '<' Spnl ("div" | "DIV") Spnl HtmlAttribute* '>'
HtmlBlockCloseDiv = '<' Spnl '/' ("div" | "DIV") Spnl '>'

HtmlBlockOpenDl = '<' Spnl ("dl" | "DL") Spnl HtmlAttribute* '>'
HtmlBlockCloseDl = '<' Spnl '/' ("dl" | "DL") Spnl '>'

HtmlBlockOpenFieldset = '<' Spnl ("fieldset" | "FIELDSET") Spnl HtmlAttribute* '>'
HtmlBlockCloseFieldset = '<' Spnl '/' ("fieldset" | "FIELDSET") Spnl '>'

HtmlBlockOpenForm = '<' Spnl ("form" | "FORM") Spnl HtmlAttribute* '>'
HtmlBlockCloseForm = '<' Spnl '/' ("form" | "FORM") Spnl '>'

HtmlBlockOpenH1 = '<' Spnl ("h1" | "H1") Spnl HtmlAttribute* '>'
HtmlBlockCloseH1 = '<' Spnl '/' ("h1" | "H1") Spnl '>'

HtmlBlockOpenH2 = '<' Spnl ("h2" | "H2") Spnl HtmlAttribute* '>'
HtmlBlockCloseH2 = '<' Spnl '/' ("h2" | "H2") Spnl '>'

HtmlBlockOpenH3 = '<' Spnl ("h3" | "H3") Spnl HtmlAttribute* '>'
HtmlBlockCloseH3 = '<' Spnl '/' ("h3" | "H3") Spnl '>'

HtmlBlockOpenH4 = '<' Spnl ("h4" | "H4") Spnl HtmlAttribute* '>'
HtmlBlockCloseH4 = '<' Spnl '/' ("h4" | "H4") Spnl '>'

HtmlBlockOpenH5 = '<' Spnl ("h5" | "H5") Spnl HtmlAttribute* '>'
HtmlBlockCloseH5 = '<' Spnl '/' ("h5" | "H5") Spnl '>'

HtmlBlockOpenH6 = '<' Spnl ("h6" | "H6") Spnl HtmlAttribute* '>'
HtmlBlockCloseH6 = '<' Spnl '/' ("h6" | "H6") Spnl '>'

HtmlBlockOpenHr = '<' Spnl ("hr" | "HR") Spnl HtmlAttribute* '>'
HtmlBlockCloseHr = '<' Spnl '/' ("hr" | "HR") Spnl '>'

HtmlBlockOpenIsindex = '<' Spnl ("isindex" | "ISINDEX") Spnl HtmlAttribute* '>'
HtmlBlockCloseIsindex = '<' Spnl '/' ("isindex" | "ISINDEX") Spnl '>'

HtmlBlockOpenMenu = '<' Spnl ("menu" | "MENU") Spnl HtmlAttribute* '>'
HtmlBlockCloseMenu = '<' Spnl '/' ("menu" | "MENU") Spnl '>'

HtmlBlockOpenNoframes = '<' Spnl ("noframes" | "NOFRAMES") Spnl HtmlAttribute* '>'
HtmlBlockCloseNoframes = '<' Spnl '/' ("noframes" | "NOFRAMES") Spnl '>'

HtmlBlockOpenNoscript = '<' Spnl ("noscript" | "NOSCRIPT") Spnl HtmlAttribute* '>'
HtmlBlockCloseNoscript = '<' Spnl '/' ("noscript" | "NOSCRIPT") Spnl '>'

HtmlBlockOpenOl = '<' Spnl ("ol" | "OL") Spnl HtmlAttribute* '>'
HtmlBlockCloseOl = '<' Spnl '/' ("ol" | "OL") Spnl '>'

HtmlBlockOpenP = '<' Spnl ("p" | "P") Spnl HtmlAttribute* '>'
HtmlBlockCloseP = '<' Spnl '/' ("p" | "P") Spnl '>'

HtmlBlockOpenPre = '<' Spnl ("pre" | "PRE") Spnl HtmlAttribute* '>'
HtmlBlockClosePre = '<' Spnl '/' ("pre" | "PRE") Spnl '>'

HtmlBlockOpenTable = '<' Spnl ("table" | "TABLE") Spnl HtmlAttribute* '>'
HtmlBlockCloseTable = '<' Spnl '/' ("table" | "TABLE") Spnl '>'

HtmlBlockOpenUl = '<' Spnl ("ul" | "UL") Spnl HtmlAttribute* '>'
HtmlBlockCloseUl = '<' Spnl '/' ("ul" | "UL") Spnl '>'

HtmlBlockOpenDd = '<' Spnl ("dd" | "DD") Spnl HtmlAttribute* '>'
HtmlBlockCloseDd = '<' Spnl '/' ("dd" | "DD") Spnl '>'

HtmlBlockOpenDt = '<' Spnl ("dt" | "DT") Spnl HtmlAttribute* '>'
HtmlBlockCloseDt = '<' Spnl '/' ("dt" | "DT") Spnl '>'

HtmlBlockOpenFrameset = '<' Spnl ("frameset" | "FRAMESET") Spnl HtmlAttribute* '>'
HtmlBlockCloseFrameset = '<' Spnl '/' ("frameset" | "FRAMESET") Spnl '>'

HtmlBlockOpenLi = '<' Spnl ("li" | "LI") Spnl HtmlAttribute* '>'
HtmlBlockCloseLi = '<' Spnl '/' ("li" | "LI") Spnl '>'

HtmlBlockOpenTbody = '<' Spnl ("tbody" | "TBODY") Spnl HtmlAttribute* '>'
HtmlBlockCloseTbody = '<' Spnl '/' ("tbody" | "TBODY") Spnl '>'

HtmlBlockOpenTd = '<' Spnl ("td" | "TD") Spnl HtmlAttribute* '>'
HtmlBlockCloseTd = '<' Spnl '/' ("td" | "TD") Spnl '>'

HtmlBlockOpenTfoot = '<' Spnl ("tfoot" | "TFOOT") Spnl HtmlAttribute* '>'
HtmlBlockCloseTfoot = '<' Spnl '/' ("tfoot" | "TFOOT") Spnl '>'

HtmlBlockOpenTh = '<' Spnl ("th" | "TH") Spnl HtmlAttribute* '>'
HtmlBlockCloseTh = '<' Spnl '/' ("th" | "TH") Spnl '>'

HtmlBlockOpenThead = '<' Spnl ("thead" | "THEAD") Spnl HtmlAttribute* '>'
HtmlBlockCloseThead = '<' Spnl '/' ("thead" | "THEAD") Spnl '>'

HtmlBlockOpenTr = '<' Spnl ("tr" | "TR") Spnl HtmlAttribute* '>'
HtmlBlockCloseTr = '<' Spnl '/' ("tr" | "TR") Spnl '>'

HtmlBlockOpenScript = '<' Spnl ("script" | "SCRIPT") Spnl HtmlAttribute* '>'
HtmlBlockCloseScript = '<' Spnl '/' ("script" | "SCRIPT") Spnl '>'

HtmlBlockInTags = HtmlBlockOpenAddress (HtmlBlockInTags | !HtmlBlockCloseAddress .)* HtmlBlockCloseAddress
                | HtmlBlockOpenBlockquote (HtmlBlockInTags | !HtmlBlockCloseBlockquote .)* HtmlBlockCloseBlockquote
                | HtmlBlockOpenCenter (HtmlBlockInTags | !HtmlBlockCloseCenter .)* HtmlBlockCloseCenter
                | HtmlBlockOpenDir (HtmlBlockInTags | !HtmlBlockCloseDir .)* HtmlBlockCloseDir
                | HtmlBlockOpenDiv (HtmlBlockInTags | !HtmlBlockCloseDiv .)* HtmlBlockCloseDiv
                | HtmlBlockOpenDl (HtmlBlockInTags | !HtmlBlockCloseDl .)* HtmlBlockCloseDl
                | HtmlBlockOpenFieldset (HtmlBlockInTags | !HtmlBlockCloseFieldset .)* HtmlBlockCloseFieldset
                | HtmlBlockOpenForm (HtmlBlockInTags | !HtmlBlockCloseForm .)* HtmlBlockCloseForm
                | HtmlBlockOpenH1 (HtmlBlockInTags | !HtmlBlockCloseH1 .)* HtmlBlockCloseH1
                | HtmlBlockOpenH2 (HtmlBlockInTags | !HtmlBlockCloseH2 .)* HtmlBlockCloseH2
                | HtmlBlockOpenH3 (HtmlBlockInTags | !HtmlBlockCloseH3 .)* HtmlBlockCloseH3
                | HtmlBlockOpenH4 (HtmlBlockInTags | !HtmlBlockCloseH4 .)* HtmlBlockCloseH4
                | HtmlBlockOpenH5 (HtmlBlockInTags | !HtmlBlockCloseH5 .)* HtmlBlockCloseH5
                | HtmlBlockOpenH6 (HtmlBlockInTags | !HtmlBlockCloseH6 .)* HtmlBlockCloseH6
                | HtmlBlockOpenHr (HtmlBlockInTags | !HtmlBlockCloseHr .)* HtmlBlockCloseHr
                | HtmlBlockOpenIsindex (HtmlBlockInTags | !HtmlBlockCloseIsindex .)* HtmlBlockCloseIsindex
                | HtmlBlockOpenMenu (HtmlBlockInTags | !HtmlBlockCloseMenu .)* HtmlBlockCloseMenu
                | HtmlBlockOpenNoframes (HtmlBlockInTags | !HtmlBlockCloseNoframes .)* HtmlBlockCloseNoframes
                | HtmlBlockOpenNoscript (HtmlBlockInTags | !HtmlBlockCloseNoscript .)* HtmlBlockCloseNoscript | HtmlBlockOpenOl (HtmlBlockInTags | !HtmlBlockCloseOl .)* HtmlBlockCloseOl
                | HtmlBlockOpenP (HtmlBlockInTags | !HtmlBlockCloseP .)* HtmlBlockCloseP
                | HtmlBlockOpenPre (HtmlBlockInTags | !HtmlBlockClosePre .)* HtmlBlockClosePre
                | HtmlBlockOpenTable (HtmlBlockInTags | !HtmlBlockCloseTable .)* HtmlBlockCloseTable
                | HtmlBlockOpenUl (HtmlBlockInTags | !HtmlBlockCloseUl .)* HtmlBlockCloseUl
                | HtmlBlockOpenDd (HtmlBlockInTags | !HtmlBlockCloseDd .)* HtmlBlockCloseDd
                | HtmlBlockOpenDt (HtmlBlockInTags | !HtmlBlockCloseDt .)* HtmlBlockCloseDt
                | HtmlBlockOpenFrameset (HtmlBlockInTags | !HtmlBlockCloseFrameset .)* HtmlBlockCloseFrameset
                | HtmlBlockOpenLi (HtmlBlockInTags | !HtmlBlockCloseLi .)* HtmlBlockCloseLi
                | HtmlBlockOpenTbody (HtmlBlockInTags | !HtmlBlockCloseTbody .)* HtmlBlockCloseTbody
                | HtmlBlockOpenTd (HtmlBlockInTags | !HtmlBlockCloseTd .)* HtmlBlockCloseTd
                | HtmlBlockOpenTfoot (HtmlBlockInTags | !HtmlBlockCloseTfoot .)* HtmlBlockCloseTfoot
                | HtmlBlockOpenTh (HtmlBlockInTags | !HtmlBlockCloseTh .)* HtmlBlockCloseTh
                | HtmlBlockOpenThead (HtmlBlockInTags | !HtmlBlockCloseThead .)* HtmlBlockCloseThead
                | HtmlBlockOpenTr (HtmlBlockInTags | !HtmlBlockCloseTr .)* HtmlBlockCloseTr
                | HtmlBlockOpenScript (HtmlBlockInTags | !HtmlBlockCloseScript .)* HtmlBlockCloseScript

HtmlBlock = < ( HtmlBlockInTags | HtmlComment | HtmlBlockSelfClosing ) >
            BlankLine+
            { $$ = mk_str(yytext); $$->key = HTMLBLOCK; }

HtmlBlockSelfClosing = '<' Spnl HtmlBlockType Spnl HtmlAttribute* '/' Spnl '>'

HtmlBlockType = "address" | "blockquote" | "center" | "dir" | "div" | "dl" | "fieldset" | "form" | "h1" | "h2" | "h3" |
                "h4" | "h5" | "h6" | "hr" | "isindex" | "menu" | "noframes" | "noscript" | "ol" | "p" | "pre" | "table" |
                "ul" | "dd" | "dt" | "frameset" | "li" | "tbody" | "td" | "tfoot" | "th" | "thead" | "tr" | "script" |
                "ADDRESS" | "BLOCKQUOTE" | "CENTER" | "DIR" | "DIV" | "DL" | "FIELDSET" | "FORM" | "H1" | "H2" | "H3" |
                "H4" | "H5" | "H6" | "HR" | "ISINDEX" | "MENU" | "NOFRAMES" | "NOSCRIPT" | "OL" | "P" | "PRE" | "TABLE" |
                "UL" | "DD" | "DT" | "FRAMESET" | "LI" | "TBODY" | "TD" | "TFOOT" | "TH" | "THEAD" | "TR" | "SCRIPT"

Inlines  =  a:StartList ( !Endline Inline { a = cons($$, a); }
                        | c:Endline &Inline { a = cons(c, a); } )+ Endline?
            { $$ = mk_list(LIST, a); }

Inline  = Str
        | LineBreak
        | Endline
        | Space
        | Strong
        | Emph
        | Image
        | Link
        | NoteReference
        | InlineNote
        | Code
        | RawHtml
        | Entity
        | EscapedChar
        | Smart
        | Symbol

Space = Spacechar+
        { $$ = mk_str(" ");
          $$->key = SPACE; }

Str =   < NormalChar+ >
        { $$ = mk_str(yytext); }

EscapedChar =   '\\' !Newline < . >
                { $$ = mk_str(yytext); }

Entity =    ( HexEntity | DecEntity | CharEntity )
            { $$ = mk_str(yytext); $$->key = HTML; }

Endline =   TerminalEndline | NormalEndline

NormalEndline =   Sp Newline !BlankLine !BlockQuote !AtxStart
                  !(Line ("===" '='* | "---" '-'*) Newline)
                  { $$ = mk_str("\n");
                    $$->key = SPACE; }

TerminalEndline = Sp Newline Eof
                  { $$ = NULL; }

LineBreak = "  " Endline
            { $$ = mk_element(LINEBREAK); }

Symbol =    < SpecialChar >
            { $$ = mk_str(yytext); }

Emph =      EmphStar | EmphUl

EmphStar =  OneStar !Spacechar !Newline
            a:StartList
            ( EmphInlineStar { a = cons($$, a); } )+
            OneStar
            { $$ = mk_list(EMPH, a); }

EmphInlineStar  = StrongStar
                | !(Spnl OneStar) Inline

EmphUl =    OneUl !Spacechar !Newline
            a:StartList
            ( EmphInlineUl { a = cons($$, a); } )+
            OneUl !Alphanumeric
            { $$ = mk_list(EMPH, a); }

EmphInlineUl    =  StrongUl
                | !(Spnl OneUl) Inline

Strong = StrongStar | StrongUl

StrongStar =    TwoStar !Spacechar !Newline
                a:StartList
                ( StrongInlineStar { a = cons($$, a); } )+
                TwoStar
                { $$ = mk_list(STRONG, a); }

StrongInlineStar =  !(Spnl TwoStar) Inline

StrongUl =  TwoUl !Spacechar !Newline
            a:StartList
            ( StrongInlineUl { a = cons($$, a); } )+
            TwoUl
            { $$ = mk_list(STRONG, a); }

StrongInlineUl = !(Spnl TwoUl) Inline

Image = '!' ( ExplicitLink | ReferenceLink )
        { $$->key = IMAGE; }

Link =  ExplicitLink | ReferenceLink | AutoLink

ReferenceLink = ReferenceLinkDouble | ReferenceLinkSingle

ReferenceLinkDouble =  a:Label < Spnl > !"[]" b:Label
                       {   link match;
                           if (find_reference(&match, b->children))
                               $$ = mk_link(a->children, match.url, match.title);
                           else {
                               element *result;
                               result = mk_element(LIST);
                               result->children = cons(mk_str("["), cons(a, cons(mk_str("]"), cons(mk_str(yytext),
                                                   cons(mk_str("["), cons(b, mk_str("]")))))));
                               $$ = result;
                           }
                       }

ReferenceLinkSingle =  a:Label < (Spnl "[]")? >
                       {   link match;
                           if (find_reference(&match, a->children)) {
                               $$ = mk_link(a->children, match.url, match.title);
                           }
                           else {
                               element *result;
                               result = mk_element(LIST);
                               result->children = cons(mk_str("["), cons(a, cons(mk_str("]"), mk_str(yytext))));
                               $$ = result;
                           }
                       }

ExplicitLink =  l:Label Spnl '(' Sp s:Source Spnl t:Title Sp ')'
                { $$ = mk_link(l->children, s->contents.str, t->contents.str);
                  free_element(s);
                  free_element(t);
                  free(l); }

Source  = ( '<' < SourceContents > '>' | < SourceContents > )
          { $$ = mk_str(yytext); }

SourceContents = ( ( !'(' !')' !'>' Nonspacechar )+ | '(' SourceContents ')')*
                 | ""

Title = ( TitleSingle | TitleDouble | < "" > )
        { $$ = mk_str(yytext); }

TitleSingle = '\'' < ( !( '\'' Sp ( ')' | Newline ) ) !Newline . )* > '\''

TitleDouble = '"' < ( !( '"' Sp ( ')' | Newline ) ) !Newline . )* > '"'

AutoLink = AutoLinkUrl | AutoLinkEmail

AutoLinkUrl =   '<' < [A-Za-z]+ "://" ( !Newline !'>' . )+ > '>'
                {   $$ = mk_link(cons(mk_str(yytext), NULL), yytext, ""); }

AutoLinkEmail = '<' < [-A-Za-z0-9+_]+ '@' ( !Newline !'>' . )+ > '>'
                {   char *mailto = malloc(strlen(yytext) + 8);
                    sprintf(mailto, "mailto:%s", yytext);
                    $$ = mk_link(cons(mk_str(yytext), NULL), mailto, "");
                    free(mailto);
                }

Reference = NonindentSpace !"[]" l:Label ':' Spnl s:RefSrc Spnl t:RefTitle BlankLine*
            { $$ = mk_link(l->children, s->contents.str, t->contents.str);
              free_element(s);
              free_element(t);
              free(l);
              $$->key = REFERENCE; }

Label = '[' ( !'^' &{ extension(EXT_NOTES) } | &. &{ !extension(EXT_NOTES) } )
        a:StartList
        ( !']' Inline { a = cons($$, a); } )*
        ']'
        { $$ = mk_list(LIST, a); }

RefSrc = < Nonspacechar+ > 
         { $$ = mk_str(yytext); 
           $$->key = HTML; }

RefTitle =  ( RefTitleSingle | RefTitleDouble | RefTitleParens | EmptyTitle )
            { $$ = mk_str(yytext); }

EmptyTitle = < "" >

RefTitleSingle = '\'' < ( !( '\'' Sp Newline | Newline ) . )* > '\''

RefTitleDouble = '"' < ( !('"' Sp Newline | Newline) . )* > '"'

RefTitleParens = '(' < ( !(')' Sp Newline | Newline) . )* > ')'

References = a:StartList
             ( b:Reference { a = cons(b, a); } | SkipBlock )*
             { references = reverse(a); }

Ticks1 = "`"
Ticks2 = "``"
Ticks3 = "```"
Ticks4 = "````"
Ticks5 = "`````"

Code = ( Ticks1 Sp < ( ( !'`' Nonspacechar )+ | !Ticks1 '`'+ | !( Sp Ticks1 ) ( Spacechar | Newline !BlankLine ) )+ > Sp Ticks1
       | Ticks2 Sp < ( ( !'`' Nonspacechar )+ | !Ticks2 '`'+ | !( Sp Ticks2 ) ( Spacechar | Newline !BlankLine ) )+ > Sp Ticks2
       | Ticks3 Sp < ( ( !'`' Nonspacechar )+ | !Ticks3 '`'+ | !( Sp Ticks3 ) ( Spacechar | Newline !BlankLine ) )+ > Sp Ticks3
       | Ticks4 Sp < ( ( !'`' Nonspacechar )+ | !Ticks4 '`'+ | !( Sp Ticks4 ) ( Spacechar | Newline !BlankLine ) )+ > Sp Ticks4
       | Ticks5 Sp < ( ( !'`' Nonspacechar )+ | !Ticks5 '`'+ | !( Sp Ticks5 ) ( Spacechar | Newline !BlankLine ) )+ > Sp Ticks5
       )
       { $$ = mk_str(yytext); $$->key = CODE; }

RawHtml =   < (HtmlComment | HtmlTag) >
            { $$ = mk_str(yytext); $$->key = HTML; }

BlankLine =     Sp Newline

Quoted =        '"' (!'"' .)* '"' | '\'' (!'\'' .)* '\''
HtmlAttribute = (Alphanumeric | '-')+ Spnl ('=' Spnl (Quoted | Nonspacechar+))? Spnl
HtmlComment =   "<!--" (!"-->" .)* "-->"
HtmlTag =       '<' Spnl '/'? Alphanumeric+ Spnl HtmlAttribute* '/'? Spnl '>'
Eof =           !.
Spacechar =     ' ' | '\t'
Nonspacechar =  !Spacechar !Newline .
Newline =       '\n' | '\r' '\n'?
Sp =            Spacechar*
Spnl =          Sp (Newline Sp)?
SpecialChar =   '*' | '_' | '`' | '&' | '[' | ']' | '<' | '!' | '\\' | ExtendedSpecialChar
NormalChar =    !( SpecialChar | Spacechar | Newline ) .
Alphanumeric =  [A-Za-z0-9]
Digit = [0-9]

HexEntity =     < '&' '#' [Xx] [0-9a-fA-F]+ ';' >
DecEntity =     < '&' '#' [0-9]+ > ';' >
CharEntity =    < '&' [A-Za-z0-9]+ ';' >

OneStar =       '*' !OneStar
OneUl   =       '_' !OneUl
TwoStar =       "**" !TwoStar
TwoUl =         "__" !TwoUl

NonindentSpace =    "   " | "  " | " " | ""
Indent =            "\t" | "    "
IndentedLine =      Indent Line
OptionallyIndentedLine = Indent? Line

# StartList starts a list data structure that can be added to with pushelt:
StartList = &.
            { $$ = NULL; }

Line =  RawLine
        { $$ = mk_str(yytext); }
RawLine = ( < (!'\r' !'\n' .)* Newline > | < .+ > Eof )

SkipBlock = ( !BlankLine RawLine )+ BlankLine*
          | BlankLine+

# Syntax extensions

ExtendedSpecialChar = &{ extension(EXT_SMART) } ('.' | '-' | '\'' | '"')
                    | &{ extension(EXT_NOTES) } ( '^' )

Smart = &{ extension(EXT_SMART) }
        ( Ellipsis | Dash | SingleQuoted | DoubleQuoted | Apostrophe )

Apostrophe = '\''
             { $$ = mk_element(APOSTROPHE); }

Ellipsis = ("..." | ". . .")
           { $$ = mk_element(ELLIPSIS); }

Dash = EmDash | EnDash

EnDash = '-' &Digit
         { $$ = mk_element(ENDASH); }

EmDash = Sp ("---" | "--") Sp
         { $$ = mk_element(EMDASH); }

SingleQuoteStart = '\'' ![)!\],.;:-? \t\n] !( ( "s" | "t" | "m" | "ve" | "ll" | "re" ) !Alphanumeric )

SingleQuoteEnd = '\'' !Alphanumeric

SingleQuoted = SingleQuoteStart
               a:StartList
               ( !SingleQuoteEnd b:Inline { a = cons(b, a); } )+
               SingleQuoteEnd
               { $$ = mk_list(SINGLEQUOTED, a); }

DoubleQuoteStart = '"'

DoubleQuoteEnd = '"'

DoubleQuoted =  DoubleQuoteStart
                a:StartList
                ( !DoubleQuoteEnd b:Inline { a = cons(b, a); } )+
                DoubleQuoteEnd
                { $$ = mk_list(DOUBLEQUOTED, a); }

NoteReference = &{ extension(EXT_NOTES) }
                ref:RawNoteReference
                {   element *match;
                    if (find_note(&match, ref->contents.str)) {
                        $$ = mk_element(NOTE);
                        assert(match->children != NULL);
                        $$->children = match->children;
                        $$->contents.str = 0;
                    } else {
                        char *s;
                        s = malloc(strlen(ref->contents.str) + 4);
                        sprintf(s, "[^%s]", ref->contents.str);
                        $$ = mk_str(s);
                        free(s);
                    }
                }

RawNoteReference = "[^" < ( !Newline !']' . )+ > ']'
                   { $$ = mk_str(yytext); }

Note =          &{ extension(EXT_NOTES) }
                NonindentSpace ref:RawNoteReference ':' Sp
                a:StartList
                ( RawNoteBlock { a = cons($$, a); } )
                ( &Indent RawNoteBlock { a = cons($$, a); } )*
                {   $$ = mk_list(NOTE, a);
                    $$->contents.str = strdup(ref->contents.str);
                }

InlineNote =    &{ extension(EXT_NOTES) }
                "^["
                a:StartList
                ( !']' Inline { a = cons($$, a); } )+
                ']'
                { $$ = mk_list(NOTE, a);
                  $$->contents.str = 0; }

Notes =         a:StartList
                ( b:Note { a = cons(b, a); } | SkipBlock )*
                { notes = reverse(a); }

RawNoteBlock =  a:StartList
                    ( !BlankLine OptionallyIndentedLine { a = cons($$, a); } )+
                ( BlankLine { a = cons($$, a); } )*
                {   $$ = mk_str_from_list(a, true);
                    $$->key = RAW;
                }

%%

/* free_element_list - free list of elements recursively */
void free_element_list(element * elt) {
    element * next = NULL;
    while (elt != NULL) {
        next = elt->next;
        free_element_contents(*elt);
        if (elt->children != NULL) {
            free_element_list(elt->children);
            elt->children = NULL;
        }
        #ifdef __DEBUG__
          fprintf(stderr,"Freed element for %d - %d\n", elt->key, elt);
        #endif
        free(elt);
        elt = next;
    }
}

/* free_element_contents - free element contents depending on type */
void free_element_contents(element elt) {
    switch (elt.key) {
      case STR:
      case SPACE:
      case RAW:
      case HTMLBLOCK:
      case HTML:
      case VERBATIM:
      case CODE:
      case NOTE:
        free(elt.contents.str);
        elt.contents.str = NULL;
        break;
      case LINK:
      case IMAGE:
        free(elt.contents.link->url);
        elt.contents.link->url = NULL;
        free(elt.contents.link->title);
        elt.contents.link->title = NULL;
        free_element_list(elt.contents.link->label);
        free(elt.contents.link);
        break;
      default:
        ;
    }
}

/* free_element - free element and contents */
void free_element(element *elt) {
    free_element_contents(*elt);
    free(elt);
}

element * parse_references(char *string, int extensions) {

    char *oldcharbuf;
    syntax_extensions = extensions;

    oldcharbuf = charbuf;
    charbuf = string;
    yyparsefrom(yy_References);    /* first pass, just to collect references */
    charbuf = oldcharbuf;

    return references;
}

element * parse_notes(char *string, int extensions, element *reference_list) {

    char *oldcharbuf;
    syntax_extensions = extensions;
    references = reference_list;

    oldcharbuf = charbuf;
    charbuf = string;
    if (extension(EXT_NOTES)) {
        charbuf = string;
        yyparsefrom(yy_Notes);     /* second pass for notes */
    }

    charbuf = oldcharbuf;
    return notes;
}

element * parse_markdown(char *string, int extensions, element *reference_list, element *note_list) {

    char *oldcharbuf;
    syntax_extensions = extensions;
    references = reference_list;
    notes = note_list;

    oldcharbuf = charbuf;
    charbuf = string;

    yyparsefrom(yy_Doc);

    charbuf = oldcharbuf;          /* restore charbuf to original value */
    return parse_result;

}

